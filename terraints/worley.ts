import {type Material, type TypedArray, Vector2, type Vector3} from "three";
import type {TerrainOptions} from "./core";
import type {Mesh} from "three/src/objects/Mesh";
import {Clamp} from "./filter";

const Vector2Functions = {
    distanceToManhattan(t: Vector2, b: Vector2) {
        return Math.abs(t.x - b.x) + Math.abs(t.y - b.y);
    },

    distanceToChebyshev(t: Vector2, b: Vector2) {
        let c = Math.abs(t.x - b.x),
            d = Math.abs(t.y - b.y);
        return c <= d ? d : c;
    },

    distanceToQuadratic(t: Vector2, b: Vector2) {
        let c = Math.abs(t.x - b.x),
            d = Math.abs(t.y - b.y);
        return c * c + c * d + d * d;
    },
}

function distanceToNearest(coords: Vector2, points: Vector2[], distanceType: string) {
    let color = Infinity,
        distanceFunc = 'distanceTo' + distanceType as keyof typeof Vector2Functions;
    for (let k = 0; k < points.length; k++) {
        let d = Vector2Functions[distanceFunc](points[k], coords);
        if (d < color) {
            color = d;
        }
    }
    return color;
}

type DistanceType = 'Manhattan' | 'Chebyshev' | 'Quadratic' | 'Squared' | '';

type WorleyDistributionFunction =
    typeof randomPoints
    | typeof PoissonDisks
    | ((width: number, height: number, numPoints: number) => Vector2[]);

interface WorleyOptions {
    mesh?: Mesh;
    material?: Material;
    frequency?: number;
    amplitude?: number;
    widthSegments?: number;
    heightSegments?: number;
    smoothSpread?: number;
    spread?: number | ((vertex: Vector3, key: number) => boolean);
    maxSlope?: number;
    maxTilt?: number;
    w?: number;
    h?: number;
    distanceType?: DistanceType;
    worleyDistanceTransformation?: (distance: number) => number;
    worleyDistribution?: WorleyDistributionFunction;
    worleyPoints?: number;
}

/**
 * Generate random terrain using Worley noise.
 *
 * Worley noise is also known as Cell or Voronoi noise. It is generated by
 * scattering a bunch of points in heightmap-space, then setting the height
 * of every point in the heightmap based on how close it is to the closest
 * scattered point (or the nth-closest point, but this results in
 * heightmaps that don't look much like terrain).
 *
 * @param {Float32Array} g
 *   The geometry's z-positions to modify with heightmap data.
 * @param {Object} options
 *   A map of settings that control how the terrain is constructed and
 *   displayed. Valid values are the same as those for the `options`
 *   parameter of {@link Terrain}(), plus three additional available
 *   properties:
 *   - `distanceType`: The name of a method to use to calculate the
 *     distance between a point in the heightmap and a Voronoi centroid in
 *     order to determine the height of that point. Available methods
 *     include 'Manhattan', 'Chebyshev', 'Quadratic', 'Squared' (squared
 *     Euclidean), and '' (the empty string, meaning Euclidean, the
 *     default).
 *   - `worleyDistanceTransformation`: A function that takes the distance
 *     from a heightmap vertex to a Voronoi centroid and returns a relative
 *     height for that vertex. Defaults to function(d) { return -d; }.
 *     Interesting choices of algorithm include
 *     `0.5 + 1.0 * Math.cos((0.5*d-1) * Math.PI) - d`, which produces
 *     interesting stepped cones, and `-Math.sqrt(d)`, which produces sharp
 *     peaks resembling stalagmites.
 *   - `worleyDistribution`: A function to use to distribute Voronoi
 *     centroids. Available methods include
 *     `Worley.randomPoints` (the default),
 *     `Worley.PoissonDisks`, and any function that returns
 *     an array of `Vector2` instances. You can wrap the PoissonDisks
 *     function to use custom parameters.
 *   - `worleyPoints`: The number of Voronoi cells to use (must be at least
 *     one). Calculated by default based on the size of the terrain.
 */
export function Worley(g: TypedArray, options: TerrainOptions & WorleyOptions) {
    let points = (options.worleyDistribution || randomPoints)(options.xSegments, options.ySegments, options.worleyPoints),
        transform = options.worleyDistanceTransformation || function (d) {
            return -d;
        },
        currentCoords = new Vector2(0, 0);
    // The height of each heightmap vertex is the distance to the closest Voronoi centroid
    for (let i = 0, xl = options.xSegments + 1; i < xl; i++) {
        for (let j = 0; j < options.ySegments + 1; j++) {
            currentCoords.x = i;
            currentCoords.y = j;
            g[j * xl + i] = transform(distanceToNearest(currentCoords, points, options.distanceType || ''));
        }
    }
    // We set the heights to distances so now we need to normalize
    Clamp(g, {
        maxHeight: options.maxHeight,
        minHeight: options.minHeight,
        stretch: true,
    } as TerrainOptions);
}

/**
 * Randomly distribute points in space.
 */
export function randomPoints(width: number, height: number, numPoints: number) {
    numPoints = numPoints || Math.floor(Math.sqrt(width * height * 0.025)) || 1;
    let points = new Array(numPoints);
    for (let i = 0; i < numPoints; i++) {
        points[i] = new Vector2(
            Math.random() * width,
            Math.random() * height
        );
    }
    return points;
}

/* Utility functions for Poisson Disks. */

function removeAndReturnRandomElement<T>(arr: T[]) {
    return arr.splice(Math.floor(Math.random() * arr.length), 1)[0];
}

function putInGrid(grid: Vector2[][], point: Vector2, cellSize: number) {
    let gx = Math.floor(point.x / cellSize),
        gy = Math.floor(point.y / cellSize);
    if (!grid[gx]) grid[gx] = [];
    grid[gx][gy] = point;
}

function inRectangle(point: Vector2, width: number, height: number) {
    return point.x >= 0 && // jscs:ignore requireSpaceAfterKeywords
        point.y >= 0 &&
        point.x <= width + 1 &&
        point.y <= height + 1;
}

function inNeighborhood(grid: Vector2[][], point: Vector2, minDist: number, cellSize: number) {
    let gx = Math.floor(point.x / cellSize),
        gy = Math.floor(point.y / cellSize);
    for (let x = gx - 1; x <= gx + 1; x++) {
        for (let y = gy - 1; y <= gy + 1; y++) {
            if (x !== gx && y !== gy &&
                typeof grid[x] !== 'undefined' && typeof grid[x][y] !== 'undefined') {
                let cx = x * cellSize,
                    cy = y * cellSize;
                if (Math.sqrt((point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy)) < minDist) {
                    return true;
                }
            }
        }
    }
    return false;
}

function generateRandomPointAround(point: Vector2, minDist: number) {
    let radius = minDist * (Math.random() + 1),
        angle = 2 * Math.PI * Math.random();
    return new Vector2(
        point.x + radius * Math.cos(angle),
        point.y + radius * Math.sin(angle)
    );
}

Worley.PoissonDisks = PoissonDisks

/**
 * Generate a set of points using Poisson disk sampling.
 *
 * Useful for clustering scattered meshes and Voronoi cells for Worley noise.
 *
 * Ported from pseudocode at http://devmag.org.za/2009/05/03/poisson-disk-sampling/
 *
 *   A map of settings that control how the resulting noise should be generated
 *   (with the same parameters as the `options` parameter to the
 *   `Terrain` function).
 *
 * @return {Vector2[]}
 *   An array of points.
 * @param width
 * @param height
 * @param numPoints
 */
function PoissonDisks(width: number, height: number, numPoints: number): Vector2[] {
    numPoints = numPoints || Math.floor(Math.sqrt(width * height * 0.2)) || 1;
    let minDist = Math.sqrt((width + height) * 2.5);
    if (minDist > numPoints * 0.67) minDist = numPoints * 0.67;
    let cellSize = minDist / Math.sqrt(2);
    if (cellSize < 2) cellSize = 2;

    let grid = [];

    let processList: Vector2[] = [],
        samplePoints: Vector2[] = [];

    let firstPoint = new Vector2(
        Math.random() * width,
        Math.random() * height
    );
    processList.push(firstPoint);
    samplePoints.push(firstPoint);
    putInGrid(grid, firstPoint, cellSize);

    let count = 0;
    while (processList.length) {
        let point = removeAndReturnRandomElement(processList);
        for (let i = 0; i < numPoints; i++) {
            // optionally, minDist = perlin(point.x / width, point.y / height)
            let newPoint = generateRandomPointAround(point, minDist);
            if (inRectangle(newPoint, width, height) && !inNeighborhood(grid, newPoint, minDist, cellSize)) {
                processList.push(newPoint);
                samplePoints.push(newPoint);
                putInGrid(grid, newPoint, cellSize);
                if (samplePoints.length >= numPoints) break;
            }
        }
        if (samplePoints.length >= numPoints) break;
        // Sanity check
        if (++count > numPoints * numPoints) {
            break;
        }
    }
    return samplePoints;
}
